
r"""
Given the output of the C-program genus4_search, we want to test
all of the resulting curves to see which are smooth and geometrically
irreducible. These will give genus-4 gonality-5 curves. 

"""

q = 4
data_dir = '../data/genus4_gonality5/'

if q == 2:
  F = GF(2) 
  a = F(1)                      # Coefficient in xy + z^2 + azw + w^2
  filename = 'genus4_GF2.data'  # data file
  swap = lambda u : u           # don't change the string reps in the data file
elif q == 3:
  F = GF(3)
  a = F(1)                      # Coefficient in xy + z^2 + aw^2
  filename = 'genus4_GF3.data'  # data file
  swap = lambda u : u           # don't change the string reps in the data file
elif q == 4:
  F.<t> = GF(4)
  a = F(t)                      # Coefficient in xy + z^2 + azw + w^2
  filename = 'genus4_GF4.data'  # data file
  swap = lambda u : u.replace('T^2+T','t') # T^2 + T = t in GF(16), per flint
else:
  raise NotImplementedError
    
################################################################################

import itertools, progress, search_tools

R.<x,y,z,w> = F[]
q = F.cardinality()
cubic_monomials = search_tools.homogeneous_monomials(R,3)
xx = R.gens()
Q = x*y + z^2 + a*z*w + w^2
first_row = [Q.derivative(u) for u in xx]
print('Computing orthogonal group ...')
if q in [2,4]:
  OQ = search_tools.char2_dim4_nonsplit_smooth_orthogonal_group(F,a)
else:
  OQ = search_tools.odd_char_dim4_nonsplit_smooth_orthogonal_group(F,a)
print('Done!\n')

print('Loading cubics from file ...')
cubic_pols = []
fp = open(data_dir + filename,'r')
for line in fp.readlines():
  s = swap(line)
  pol = R(s)
  cubic_pols.append(pol)
print('Found {} cubic polynomials\n'.format(len(cubic_pols)))
fp.close()

seen = set()
orbit_reps = []
prog = progress.Progress(len(cubic_pols))
print('Identifying cubic generators of ideals ...')
for pol in cubic_pols:
  prog()
  if pol in seen: continue
  orbit_reps.append(pol)
  # print('len(orbit_reps) = {}, len(seen) = {}'.format(len(orbit_reps),len(seen)))
  for g in OQ:
    new_pol = search_tools.evaluate_poly(pol,g*vector(xx))
    # The x^3 coefficient is nonzero because this is a pointless curve. Set it to 1.
    new_pol *= (1/new_pol.monomial_coefficient(x^3))
    # Adjust by subtracting off an appropriate multiple of Q
    # to kill the x^2y, xy^2, z^3, and w^3 coefficients
    new_pol -= new_pol.monomial_coefficient(x^2*y)*x*Q
    new_pol -= new_pol.monomial_coefficient(x*y^2)*y*Q
    new_pol -= new_pol.monomial_coefficient(z^3)*z*Q
    new_pol -= new_pol.monomial_coefficient(w^3)*w*Q
    seen.add(new_pol)
  if len(seen) == len(cubic_pols): break
prog.finalize()
print('Number of orbits of ideals generated by a cubic and Q: {}\n'.format(len(orbit_reps)))

good_cubics = []
prog = progress.Progress(len(orbit_reps))
for pol in orbit_reps:
  prog()
  second_row = [pol.derivative(t) for t in xx]
  J = matrix(R,2,4,[first_row,second_row])
  sing_ideal = R.ideal([pol,Q] + J.minors(2))
  if search_tools.ideal_dimension(sing_ideal) != 0: continue
  good_cubics.append(pol)
prog.finalize()


